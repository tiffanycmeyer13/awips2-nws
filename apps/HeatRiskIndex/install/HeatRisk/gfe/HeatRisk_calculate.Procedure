# SVN: $Rev: 32750 $  $Date: 2022-07-08 21:25:03 +0000 (Fri, 08 Jul 2022) $
# URL: $URL: https://vlab.noaa.gov/svn/nwsscp/Gfe/Apps/HeatRisk/tags/latest_stable/gfe/HeatRisk_calculate.Procedure $
#
# ----------------------------------------------------------------------------
# This software is in the public domain, furnished "as is", without technical
# support, and with no warranty, express or implied, as to its usefulness for
# any purpose.
#
# HeatRisk_calculate Version: 2.2 07/08/2022
#
# Authors:
#    Paul Iniguez, PSR SOO
#    Mark Loeffelbein, WR/STID
#
# This script calculate the daily HeatRisk based on Obs and Fcst data. It also
# recommends what WWA to issue. This should be run on-demand by forecasters.
#
# v2.2 - Switched to usign DAF to find zones in CWA.
#        Remove despeckle for zones listed in zonesExcludedFromDS and NCEI climate points.
# ----------------------------------------------------------------------------
#  SOFTWARE HISTORY
#
# Date          Ticket#  Engineer       Description
# ------------- -------- ---------      --------------------------------------
# Sep 08, 2022  23085    mgamazaychikov Baselined for awips2 
#
##

badSites = ["USC00268186", "USW00046168", "USW00004134", "USW00093243","USC00202395","USC00416499","USC00046168","USW00093193","USC00040449","USC00040343","USW00093010","USC00246238"]
stationsToChange={}
zonesExcludedFromDS=['AZ005','AZ006']

MenuItems = ["Populate"]
import SmartScript, datetime, numpy as np, pickle, os, re
from ufpy.dataaccess import DataAccessLayer

class Procedure (SmartScript.SmartScript):
    def __init__(self, dbss):
        SmartScript.SmartScript.__init__(self, dbss)
        
    def execute(self):
        #
        ##################################################
        #
        # Make sure HeatRisk grids are loaded and clean...
        #
        ##################################################
        #
        HEATRISK_DATA_DIR = '/awips2/edex/data/share/HeatRiskIndex/data/climo/HeatRisk/data/'
        HEATRISK_DATA_DIR_LEVELS = HEATRISK_DATA_DIR +'levels/'
        dbID = self.findDatabase('Fcst')
        for p in ['MaxT', 'MinT', 'Hazards', 'HeatImpactLevelsMaxT', 'HeatImpactLevelsMinT', 'HeatRisk', 'HeatRiskWWA', 'HeatRiskWWAbyZone']:
            self.loadParm(dbID, p, 'SFC')
        dbID = self.findDatabase('Climo')
        for p in ['MaxT', 'HeatRedMaxT', 'HeatOrangeMaxT', 'HeatYellowMaxT', 'MinT', 'HeatRedMinT', 'HeatOrangeMinT', 'HeatYellowMinT']:
           self.loadParm(dbID, p, 'SFC')
        #
        tr = self.createTimeRange(-100, 300)
        self.deleteGrid('Fcst', 'HeatImpactLevelsMaxT', 'SFC', tr)
        self.deleteGrid('Fcst', 'HeatImpactLevelsMinT', 'SFC', tr)
        self.deleteGrid('Fcst', 'HeatRisk', 'SFC', tr)
        self.deleteGrid('Fcst', 'HeatRiskWWA', 'SFC', tr)
        self.deleteGrid('Fcst', 'HeatRiskWWAbyZone', 'SFC', tr)
        #
        ##################################################
        #
        # Load/set various parms and arrays
        #
        ##################################################
        #
        # Get WFO ID
        #
        wfo = self.getSiteID().strip()
        #
        # Make a mask of all the zones within the GFE domain.
        #
        states = ['AL','AK','AZ','AR','CA','CO','CT','DC','DE','FL','GA','HI','ID','IL','IN','IA','KS','KY','LA','ME',
                  'MD','MA','MI','MN','MS','MO','MT','NE','NV','NH','NJ','NM','NY','NC','ND','OH','OK','OR','PA','RI',
                  'SC','SD','TN','TX','UT','VT','VA','WA','WV','WI','WY']
        # Get a list of all edit areas and use the ones that conform to Zone names.
        zones = [z for z in self.editAreaList() if (re.search('^[A-Z]{2}Z[0-9]{3}$', z) and z[:2] in states)]
        
        # Make a mask of all the zones the GFE (not just CWA) has defined from the list obtained above.
        wfosMask = np.array([self.encodeEditArea(z) for z in zones]).any(axis=0)
        #
        # Make a list of zones within the CWA (via DAF).
        #
        reqParms = {'datatype' : 'maps',
                    'table' : 'mapdata.zone',
                    'locationField' : 'cwa',
                    'geomField' : 'the_geom',
                    'locationNames' : [wfo],
                    'parameters' : ['state', 'zone'],
                    }
        req = DataAccessLayer.newDataRequest(**reqParms)
        result = DataAccessLayer.getGeometryData(req)
        zones = [record.getString('state')+'Z'+record.getString('zone') for record in result]
        
        # Create a mask that will not apply the despeckle algorithm to.
        despeckleMask = self.empty(np.bool)
        exclz = []
        for z in zonesExcludedFromDS:
            if z in zones:
                exclz.append(z)
        if len(exclz)>0:
            despeckleMask = np.array([self.encodeEditArea(z) for z in exclz]).any(axis=0)
        
        # Get the NCEI clmate points from the install files. Then add them to the despeckleMask
        # to keep the despeckle algorithm from removing single points at NCEI locations.                
        climoPoints = self.getDataLocations()
        pointMask = self.createMaskFromPoints(climoPoints)
        despeckleMask[pointMask] = True
        
        #
        # Get list of zones and those where no advisory is to be issued
        #
 
        fn = HEATRISK_DATA_DIR + 'noAdvisory.pck'
        noAdvisory = pickle.load( open(fn, 'rb'))
        #
        # Load Diurnal Range Modifier needs to be used (created during install process)
        #
        fn = HEATRISK_DATA_DIR + 'DRM.npy'
        DRM = pickle.load( open(fn, 'rb'))
        #
        # Load array of grid point lon values
        #
        lats, lons = self.getLatLonGrids()
        #
        # Load the 99.9th percentile grid
        #
        fn = HEATRISK_DATA_DIR + 'p9999.npy'
        p9999 = np.load(fn)
        #
        # Load the maximum MaxT Normal
        #
        fn = HEATRISK_DATA_DIR + 'MaxMaxT.npy'
        MaxMaxTNormal = np.load(fn)
        #
        # Load the red/orange base values
        #
        fn = HEATRISK_DATA_DIR_LEVELS + 'redLineTmax0101.npy'
        redBaseMaxT    = np.load(fn)

        fn = HEATRISK_DATA_DIR_LEVELS + 'orangeLineTmax0101.npy'
        orangeBaseMaxT = np.load(fn)

        fn = HEATRISK_DATA_DIR_LEVELS + 'redLineTmin0101.npy'
        redBaseMinT    = np.load(fn)

        #
        # Initiate dict to hold daily temperature, HIL, and HR arrays
        #
        Grids = {
            'MaxT': [], 'MinT': [],
            'RedMaxT': [], 'OrangeMaxT': [], 'YellowMaxT': [],
            'RedMinT': [], 'OrangeMinT': [], 'YellowMinT': [],
            'HILMaxT': [], 'HILMinT': [], 'HR': [],
        }
        #
        ##################################################
        #
        # Obtain Observed/Forecast MaxT/MinT Grids and calculate HIL
        #
        ##################################################
        #
        # Set a variable to the current time
        #
        now = datetime.datetime.now()
        #
        # Go through MaxT and MinT
        #
        for parm in ['MaxT', 'MinT']:
            #
            # Set necessary parameters
            #
            if parm == 'MaxT': mode = 'Max'
            if parm == 'MinT': mode = 'Min'
            #
            # Find start time and duration of grid (can vary by office)
            #
            tr = self.createTimeRange(0, 240, 'Climo')
            gridTimes = self.getGridInfo('Climo', parm, 'SFC', tr)
            startTime = gridTimes[0].gridTime().startTime().hour
            duration = gridTimes[0].gridTime().duration()/60./60.
            #
            # Loop through the past 3 days and next 9/10 (allows for full calculations)
            #
            for d in range(-2, [9 if parm is 'MaxT' else 10][0]):
                #
                # Access in descending order Obs/URMA/Fcst/NBM
                #
                for model in ['Obs','URMA','Fcst','NBM']:
                    #
                    # Build timerange, pull grid
                    #
                    tr = self.createTimeRange(d*24+startTime, d*24+startTime+duration, model)
                    grid = self.getGrids(model, parm, "SFC", tr, noDataError=0, mode=mode)
                    #
                    # If a valid grid was obtained...
                    #
                    if grid is not None:
                        #
                        # If it is an observation grid (Obs/URMA), check
                        # to make sure the current time is beyond the end of the grid.
                        #
                        gridhistory = self.getGridHistory(model, parm, 'SFC', tr)
                        endTime = gridhistory[0][0][2].endTime().timetuple()
                        endTime = datetime.datetime(endTime.tm_year, endTime.tm_mon, endTime.tm_mday, endTime.tm_hour) 
                        if model in ['Obs','URMA'] and now > endTime:
                            break
                        elif model in ['Fcst','NBM']:
                            break
                if grid is None:
                    print('Could not find data for day', d)
                    return
                #
                # Store the ob/forecast grid
                #

                Grids[parm].append(grid)
                #
                # Pull the levels for the corresponding timerange
                #
                if parm == 'MaxT':
                    fn = HEATRISK_DIR_LEVELS+'redLineTmax{}.npy'.format(tr.startTime().strftime('%m%d')))
                    red = np.load(fn)

                    fn = HEATRISK_DIR_LEVELS+'orangeLineTmax{}.npy'.format(tr.startTime().strftime('%m%d'))
                    orange = np.load(fn)

                    fn = HEATRISK_DIR_LEVELS+'yellowLineTmax.npy'
                    yellow = np.load(fn)
                else:
                    fn = HEATRISK_DIR_LEVELS+'redLineTmin{}.npy'.format(tr.endTime().strftime('%m%d'))
                    red = np.load(fn)

                    fn = HEATRISK_DIR_LEVELS+'orangeLineTmin{}.npy'.format(tr.endTime().strftime('%m%d'))
                    orange = np.load(fn)

                    fn = HEATRISK_DIR_LEVELS+'yellowLineTmin.npy'
                    yellow = np.load(fn)
                #
                # Add to Grids array for later use
                #
                Grids['Red'+parm].append(red)
                Grids['Orange'+parm].append(orange)
                Grids['Yellow'+parm].append(yellow)
                #
                # Compute the HIL grid
                #
                HIL = red * 0
                HIL[grid>=yellow] = 1
                HIL[grid>=orange] = 2
                HIL[grid>=red] = 3
                #
                # Round the HIL output and mask to WFOs area
                #
                HIL = np.round(HIL+0.005, 0)
                HIL = np.where(wfosMask, HIL, 0)
                #
                # Create the grid, store the array
                #
                tr = self.createTimeRange(d*24+startTime, d*24+startTime+duration, 'Fcst')
                self.createGrid("Fcst", "HeatImpactLevels"+parm, "SCALAR", HIL.astype("float32"), tr)
                Grids['HIL'+parm].append(HIL)
            #
            # Save grids
            #
            self.saveElements(['HeatImpactLevels'+parm])
        #
        ###############################################################
        #
        #  Calculate Initial HeatRisk
        #
        ###############################################################
        #
        # Iterate through the number of MaxT grids
        #
        for d in range(len(Grids['MaxT'])):
            #
            # Initiate empty HeatRisk grid for today
            #
            HR = Grids['MaxT'][d].copy() * 0
            #
            # Equation for locations west of 104 deg...
            #
            HR = np.where(lons<-104, (2.00*Grids['HILMaxT'][d] + 0.35*Grids['HILMinT'][d] + 0.65*Grids['HILMinT'][d+1])/3.0, HR)
            #
            # Equation for locations east of 97 deg
            #
            HR = np.where(lons>-97, (1.80*Grids['HILMaxT'][d] + 1.10*Grids['HILMinT'][d] + 1.10*Grids['HILMinT'][d+1])/4.0, HR)
            #
            # Equation for central areas with DRM
            #
            HR = np.where( (lons>=-104)&(lons<=-97)&(DRM), (1.80*Grids['HILMaxT'][d] + 1.10*Grids['HILMinT'][d] + 1.10*Grids['HILMinT'][d+1])/4.0, HR)
            #
            # Equation for central areas without DRM
            #
            HR = np.where( (lons>=-104)&(lons<=-97)&(~DRM), (2.00*Grids['HILMaxT'][d] + 0.35*Grids['HILMinT'][d] + 0.65*Grids['HILMinT'][d+1])/3.0, HR)
            #
            # Round output
            #
            HR = HR.round(2)
            #
            # Identify periods of approaching next higher category (moist areas only),
            # done in consideration of humid/moist conditions.
            #
            # Apply only to places where the DRM applies and east of 104 deg
            #
            mask = np.where( (lons>-104) & (DRM), True, False)
            #
            # Define the upper part of the red and orange distributions ("hump")
            #
            hump_red = np.round((Grids['RedMaxT'][d] + redBaseMaxT)/2 + 0.005, 0)
            hump_orange = np.round((Grids['OrangeMaxT'][d] + orangeBaseMaxT)/2 + 0.005, 0)
            #
            # For identified locations, apply following adjustments...
            #
            # Where MaxT values are in the "red hump"...
            #
            # ...and the Max/Min/Min is 2/3/3 add 0.2 (elevates ADVY to WARN)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['RedMaxT'][d]) & (Grids['MaxT'][d]>=hump_red) & (Grids['HILMaxT'][d]==2) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==3), HR+0.2, HR)
            #
            # ...and the Max/Min/Min is 2/2/3 add 0.4 (elevates ADVY to WARN)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['RedMaxT'][d]) & (Grids['MaxT'][d]>=hump_red) & (Grids['HILMaxT'][d]==2) & (Grids['HILMinT'][d]==2) & (Grids['HILMinT'][d+1]==3), HR+0.4, HR)
            #
            # ...and the Max/Min/Min is 2/3/2 add 0.2 (elevates CONS to ADVY)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['RedMaxT'][d]) & (Grids['MaxT'][d]>=hump_red) & (Grids['HILMaxT'][d]==2) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==2), HR+0.2, HR)
            #
            # ...and the Max/Min/Min is 2/1/3 add 0.4 (elevates CONS to ADVY)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['RedMaxT'][d]) & (Grids['MaxT'][d]>=hump_red) & (Grids['HILMaxT'][d]==2) & (Grids['HILMinT'][d]==1) & (Grids['HILMinT'][d+1]==3), HR+0.4, HR)
            #
            # ...and the Max/Min/Min is 2/3/1 add 0.4 (elevates CONS to ADVY)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['RedMaxT'][d]) & (Grids['MaxT'][d]>=hump_red) & (Grids['HILMaxT'][d]==2) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==1), HR+0.4, HR)
            #
            # Where MaxT values are in the "orange hump"...
            #
            # ...and the Max/Min/Min is 1/3/3 add 0.35 (elevates CONS to ADVY)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['OrangeMaxT'][d]) & (Grids['MaxT'][d]>=hump_orange) & (Grids['HILMaxT'][d]==1) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==3), HR+0.35, HR)
            #
            # ...and the Max/Min/Min is 1/2/3 add 0.25 (elevates NONE to CONS)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['OrangeMaxT'][d]) & (Grids['MaxT'][d]>=hump_orange) & (Grids['HILMaxT'][d]==1) & (Grids['HILMinT'][d]==2) & (Grids['HILMinT'][d+1]==3), HR+0.25, HR)
            #
            # ...and the Max/Min/Min is 1/3/2 add 0.25 (elevates NONE to CONS)
            HR = np.where( (mask) & (Grids['MaxT'][d]<Grids['OrangeMaxT'][d]) & (Grids['MaxT'][d]>=hump_orange) & (Grids['HILMaxT'][d]==1) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==2), HR+0.25, HR)
            #
            # Where both MinT values are above the red base and Max/Min/Min is 2/2/2 add 0.4 (elevated CONS to ADVY)
            HR = np.where( (mask) & (Grids['MinT'][d]>=redBaseMinT) & (Grids['MinT'][d+1]>=redBaseMinT) & (Grids['HILMaxT'][d]==2) & (Grids['HILMinT'][d]==2) & (Grids['HILMinT'][d+1]==2), HR+0.4, HR)
            #
            # Where both MinT values are above the red base and Max/Min/Min is 3/2/2 add 0.2 (elevated ADVY to WARN)
            HR = np.where( (mask) & (Grids['MinT'][d]>=redBaseMinT) & (Grids['MinT'][d+1]>=redBaseMinT) & (Grids['HILMaxT'][d]==3) & (Grids['HILMinT'][d]==2) & (Grids['HILMinT'][d+1]==2), HR+0.2, HR)
            #
            #  Store initial HeatRisk array
            Grids['HR'].append(HR)
            #
        ###############################################################
        #
        #  Calculate Second-Pass HeatRisk
        #
        ###############################################################
        #
        # Make a second pass through for calculations that need HR from
        # yesterday/tomorrow (truncated by one day front/back)
        #
        for d in range(1, len(Grids['MaxT'])):
            #
            # Adjust to avoid not have warning period end with advisory due to warm/humid night...
            #
            # ...where Max/Min/Min is 3/3/1 and yesterday's HeatRisk is >2.64 add 0.2 (elevated ADVY to WARN)
            Grids['HR'][d] = np.where( (mask) & (Grids['HR'][d-1]>2.64) & (Grids['HILMaxT'][d]==3) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==1), Grids['HR'][d]+0.2, Grids['HR'][d])
            #
            # ...where Max/Min/Min is 3/1/3 and yesterday's HeatRisk is >2.64 add 0.2 (elevated ADVY to WARN)
            Grids['HR'][d] = np.where( (mask) & (Grids['HR'][d-1]>2.64) & (Grids['HILMaxT'][d]==3) & (Grids['HILMinT'][d]==1) & (Grids['HILMinT'][d+1]==3), Grids['HR'][d]+0.2, Grids['HR'][d])
            #
            # For non-DRM areas, check for dry scenario when one low MinT terminates warning early add 0.1 (elevated ADVY to WARN)
            Grids['HR'][d] = np.where( (~mask) & (Grids['HR'][d-1]>2.64) & (Grids['HILMaxT'][d]==3) & (Grids['HILMinT'][d]==3) & (Grids['HILMinT'][d+1]==1), Grids['HR'][d]+0.1, Grids['HR'][d])
            #
            # Identify areas where the HR yesterday was 3 and today is 3, then assign as 4 (magenta).
            #
            Grids['HR'][d] = np.where( (Grids['HR'][d-1]>=3.0) & (Grids['HR'][d]==3.0), 4, Grids['HR'][d])
            #
        ###############################################################
        #
        #  Calculate Third-Pass HeatRisk
        #
        ###############################################################
        #
        # Remove single magenta days (note not run for first/last day)
        #
        for d in range(1, len(Grids['MaxT'])-1):
            #
            # Adjust for "warm" climates (max normal 90+) to remove single magenta days
            #
            Grids['HR'][d] = np.where( (MaxMaxTNormal>=90) & (Grids['HR'][d-1]<4) & (Grids['HR'][d]==4) & (Grids['HR'][d+1]<4), 3, Grids['HR'][d])
            #
        ###############################################################
        #
        #  Calculate Fourth-Pass HeatRisk
        #
        ###############################################################
        #
        # Nudge near-all-time-record days up. (note not run for first/last day)
        #
        for d in range(1, len(Grids['MaxT'])-1):
            #
            # Adjust to ensure days with MaxT AOB the 99.99th percentile but below 90F and above 65F are (high) orange
            #
            Grids['HR'][d] = np.where( (Grids['MaxT'][d]>=p9999[0]) & (Grids['MaxT'][d]<90) & (Grids['MaxT'][d]>=65), np.maximum(Grids['HR'][d], 2.36), Grids['HR'][d])
            #
            # Adjust to ensure days with MaxT AOB 99.99th percentile and 90F+ are red
            #
            Grids['HR'][d] = np.where( (Grids['MaxT'][d]>=p9999[0]) & (Grids['MaxT'][d]>=90), np.maximum(Grids['HR'][d], 3.0), Grids['HR'][d])
            #
            #  Adjust to ensure days with MaxT AOB 99.99th percentile and 100F+ are magenta
            #
            Grids['HR'][d] = np.where( (Grids['MaxT'][d]>=p9999[0]) & (Grids['MaxT'][d]>=100), 4.0, Grids['HR'][d])
            #
            # Adjust to ensure if MinT AOB 99.99th percentile (and at least 75F) and MaxT is red, day is magenta
            #
            Grids['HR'][d] = np.where( (Grids['MinT'][d]>=p9999[1]) & (Grids['MinT'][d]>=75) & (Grids['HILMaxT'][d]==3), 4.0, Grids['HR'][d])
            #
            # Adjust to ensure if MinT AOB 99.99th percentile (and at least 75F) and MaxT is orange, day is red
            #
            Grids['HR'][d] = np.where( (Grids['MinT'][d]>=p9999[1]) & (Grids['MinT'][d]>=75) & (Grids['HILMaxT'][d]==2), np.maximum(Grids['HR'][d], 3.0), Grids['HR'][d])
            #
            # Adjust to push near-magenta days to magenta following a magenta
            #
            Grids['HR'][d] = np.where( (Grids['HR'][d-1]==4) & (Grids['HR'][d]>2.61), 4.0, Grids['HR'][d])
            #
            # Apply the WFOs mask
            #
            Grids['HR'][d] = np.where(wfosMask, Grids['HR'][d], 0)
            #
        ###############################################################
        #
        #  Create HeatRisk Grids
        #
        ###############################################################
        #
        # Loop through two less (won't plot first/last).
        #
        for d in range(1,len(Grids['HR'])-1):
            #
            # Create the final HeatRnp.round(Grids['HR'][d]+0.005)isk grid. The timerange is adjusted to correctly plot
            # starting with yesterday's HeatRisk. Note the rounding.
            # 
            tr = self.createTimeRange((d-2)*24+6, (d-2)*24+6+24, 'Fcst')
            #
            # Apply process to remove single pixel
            #
            HR = self.despeckle(np.where(wfosMask, np.round(Grids['HR'][d]+0.005), 0),despeckleMask)
            
            self.createGrid('Fcst', 'HeatRisk', 'SCALAR', HR.astype('float32'), tr)
            self.saveElements(['HeatRisk'])
            #
            # Now create the recommended product grid
            #
            HRWWA = np.where(Grids['HR'][d] >= 2.00, 1, 0)
            HRWWA = np.where(Grids['HR'][d] >= 2.35, 2, HRWWA)
            HRWWA = np.where(Grids['HR'][d] >= 2.62, 3, HRWWA)
            #
            # For WFOs generally east of 100 deg, use "Consider/Recommended" approach.
            #
            if np.mean(lons) > -100 or wfo in ['ABR','GID','OUN','SJT','EWX']:
                HRWWA = np.where( (lons>-104) & (HRWWA>=2), 4, HRWWA)
            #
            # Now check each zone and determine the median value, then set the whole zone to that median value
            #
            # Start by initializing an empty grid
            HeatRiskWWA_Median = self.empty()
            #
            # Loop through each zone
            #
            for zone in zones:
                #
                # Make a zone mask
                #
                mask = self.getEditArea(zone)
                #
                # This is needed to make sure zone is a defined edit area
                # encodeEditArea throws an error rather than returning None
                #
                if mask is None:
                    continue
                mask = self.encodeEditArea(zone)
                #
                # Define the zone as its median value.
                #
                med = np.median(HRWWA[mask])
                #
                # If a HT.Y is suggested but it is in the list of No Advisory zones,
                # do not assign the value. Otherwise assign the suggested product to
                # the masked area.
                #
                if med < 2.35 and zone in noAdvisory:
                    pass
                else:
                    HeatRiskWWA_Median = np.where(mask, med, HeatRiskWWA_Median)
                #
                # Create Grids
                #
            keys = ["None", "Consider", "Advisory", "Warning", "Recommended"]
            self.createGrid("Fcst", "HeatRiskWWA", "DISCRETE", (HRWWA.astype(np.int8), keys), tr,
                     discreteKeys=keys, discreteAuxDataLength=0, discreteOverlap=0,
                     defaultColorTable="GFE/HeatRiskWWA")
            self.createGrid("Fcst", "HeatRiskWWAbyZone", "DISCRETE", (HeatRiskWWA_Median.astype(np.int8), keys), tr,
                     discreteKeys=keys, discreteAuxDataLength=0, discreteOverlap=0,
                     defaultColorTable="GFE/HeatRiskWWA")
        #
        # Save the Output
        self.saveElements(['HeatRisk','HeatRiskWWA','HeatRiskWWAbyZone'])

    def despeckle(self, grid,excludeMask=None):
        #
        pixelMask = np.ones(grid.shape, bool)
        pixelMask[:, 1:] = np.logical_and(pixelMask[:, 1:], grid[:, :-1] != grid[:, 1:])# left
        pixelMask[:, :-1] = np.logical_and(pixelMask[:, :-1], grid[:, 1:] != grid[:, :-1])# right
        pixelMask[1:, :] = np.logical_and(pixelMask[1:, :], grid[:-1, :] != grid[1:, :])# above
        pixelMask[:-1, :] = np.logical_and(pixelMask[:-1, :], grid[1:, :] != grid[:-1, :])# below
        pixelMask2 = np.ones(grid.shape, bool)
        pixelMask2[:-1, 1:] = np.logical_and(pixelMask2[:-1, 1:], grid[1:, :-1] != grid[:-1, 1:])# right/below
        pixelMask2[:-1, :-1] = np.logical_and(pixelMask2[:-1, :-1], grid[1:, 1:] != grid[:-1, :-1])# right/below
        pixelMask2[1:, 1:] = np.logical_and(pixelMask2[1:, 1:], grid[:-1, :-1] != grid[1:, 1:])# left/above
        pixelMask2[1:, :-1] = np.logical_and(pixelMask2[1:, :-1], grid[:-1, 1:] != grid[1:, :-1])# right/above
        pixelMask2 = np.logical_not(pixelMask2) # Reverse True/False so values can be combined with pixelMask
        pixelMask[pixelMask2] = False # Create single mask of all single pixels.
        gridOriginal = grid.copy()
        #
        '''Adapted from SmoothLots tool '''
        k = 3 # has to be integer number of gridpoints
        (ny, nx)=grid.shape
        k2=k*2
        #
        #  Remove the minimum from the grid so that cumsum over a full
        #  row or column of the grid doesn't get so big that precision
        #  might be lost.
        #
        fullmin=np.minimum.reduce(np.minimum.reduce(grid))
        gridmin=grid-fullmin
        #
        #  Average over the first (y) dimension - making the 'mid' grid
        #
        mid=grid*0.0
        c=np.cumsum(gridmin, 0)
        nym1=ny-1
        midy=int((ny-1.0)/2.0)
        ymax=min(k+1, midy+1)
        for j in range(ymax): # handle edges
            jk=min(j+k, nym1)
            jk2=max(nym1-j-k-1, -1)
            mid[j,:]=c[jk,:]/float(jk+1)
            if jk2==-1:
                mid[nym1-j,:]=c[nym1,:]/float(jk+1)
            else:
                mid[nym1-j,:]=(c[nym1,:]-c[jk2,:])/float(jk+1)
        #
        #  The really fast part
        #
        if ((k+1)<=(ny-k)): # middle
            mid[k+1:ny-k,:]=(c[k2+1:,:]-c[:-k2-1,:])/float(k2+1)
        #
        #  Average over the second (x) dimension - making the 'out' grid
        #
        c=np.cumsum(mid, 1)
        out=grid*0.0
        nxm1=nx-1
        midx=int((nx-1.0)/2.0)
        xmax=min(k+1, midx+1)
        for j in range(xmax): # handle edges
            jk=min(j+k, nxm1)
            jk2=max(nxm1-j-k-1, -1)
            out[:, j]=c[:, jk]/float(jk+1)
            if jk2==-1:
                out[:, nxm1-j]=c[:, nxm1]/float(jk+1)
            else:
                out[:, nxm1-j]=(c[:, nxm1]-c[:, jk2])/float(jk+1)
        #
        #  The really fast part
        #
        if ((k+1)<=(nx-k)): # middle
            out[:, k+1:nx-k]=(c[:, k2+1:]-c[:, :-k2-1])/float(k2+1)
        #
        #  Add the minimum back in
        #
        out += fullmin
        #
        gridOriginal[pixelMask] = out[pixelMask]
        #
        if excludeMask is not None:
            gridOriginal[excludeMask] = grid[excludeMask]
        return gridOriginal
    
    def getDataLocations(self):
        #
        valuelist=[]
        
        pointFile = '/awips2/edex/data/share/HeatRiskIndex/runtime/PrismHiRes/data/Normals.0101.txt'
        if os.path.exists(pointFile):
            datalines = open(pointFile).readlines()
        else:
            return None
        
        #
        for line in datalines:
            #
            # Get values
            #

            id, lat, lon, maxvalue, minvalue = line.strip().split(",")

            latf, lonf = float(lat), float(lon)
            x, y = self.getGridCell(latf, lonf)
            #
            # If the ID is in domain and in reject list, reject it
            #
            if id in badSites and x is not None and y is not None:
                continue
            #
            # If station is in domain and requested to be moved, move it
            #
            if id in stationsToChange and x is not None and y is not None:
                latf = float(stationsToChange[id][0])
                lonf = float(stationsToChange[id][1])
                x, y = self.getGridCell(latf, lonf)
            #
            # Finally, add it to the list
            #
            if x is not None and y is not None:
                valuelist.append((x, y))
        #
        return valuelist
    
    def createMaskFromPoints(self,climoPoints):
        mask = self.empty(np.bool)
        for (x,y) in climoPoints:
            mask[y][x] = True
        return mask
