/**
 *
 * gov.noaa.nws.ost.edex.plugin.regionalsat.decoder.RegionalSatDecoder
 *
 * 12-01-11
 *
 * This code has been developed by the NWS/OST/SEC for use in the AWIPS2 system.
 *
 **/

package gov.noaa.nws.ost.edex.plugin.regionalsat.decoder;

import java.util.Calendar;
import java.util.TimeZone;

import com.raytheon.edex.exception.DecoderException;
import com.raytheon.edex.plugin.AbstractDecoder;
import com.raytheon.edex.util.satellite.SatSpatialFactory;
import com.raytheon.uf.common.dataplugin.PluginDataObject;
import com.raytheon.uf.common.dataplugin.satellite.SatMapCoverage;
import com.raytheon.uf.common.dataplugin.satellite.SatelliteRecord;
import com.raytheon.uf.common.datastorage.records.IDataRecord;
import com.raytheon.uf.common.status.IUFStatusHandler;
import com.raytheon.uf.common.status.UFStatus;
import com.raytheon.uf.common.time.DataTime;
import com.raytheon.uf.common.time.util.TimeUtil;

import gov.noaa.nws.ost.edex.plugin.regionalsat.util.RegionalSatLookups;
import gov.noaa.nws.ost.edex.plugin.regionalsat.util.RegionalSatLookups.PhysicalElementValue;
import ucar.nc2.Attribute;
import ucar.nc2.NetcdfFile;

/**
 * Decoder implementation for alaska and regional satellite plugin. This decoder
 * ingests netcdf3 files generated by the Alaska Region and GOES-R Proving
 * Ground for their satellite data.
 *
 * The following are the relevant elements in the netcdf3 files being used by
 * the decoder dimensions: y = 1024 ; x = 1280 ;
 *
 * variables: byte image(y, x) ; double validTime ; validTime:units = "seconds
 * since 1970-1-1 00:00:00.00 0:00" ; validTime:long_name = "Valid Time" ;
 *
 * global attributes: :channel = "0.58 - 0.68 micron VISL" ; :depictorName =
 * "AkSec1a1" ; :satelliteName = "HRPT" ; :projName = "STEREOGRAPHIC" ;
 * :centralLat = 90.f ; :centralLon = -156.f ; :lat00 = 62.057667f ; :lon00 =
 * -168.81633f ; :latNxNy = 52.910168f ; :lonNxNy = -146.53101f ; :dxKm =
 * 1.0164f ; :dyKm = 1.0164f ; :latDxDy = 58.f ; :lonDxDy = -156.f ;
 *
 * <pre>
 *
 * SOFTWARE HISTORY
 *
 * Date          Ticket#     Engineer    Description
 * -----------  ----------  ----------- --------------------------
 * Jul 15, 2011             tk          Initial Creation
 * Jul 12, 2012 798         jkorman     Changed projection "magic" numbers
 * Sep 24, 2012 1210        jkorman     Modified the decode method to create the
 *                                      IDataRecord required by the SatelliteDao
 * Aug 30, 2013 2298        rjpeter     Make getPluginName abstract
 * Apr 15, 2014 3017        bsteffen    Call new methods in SatSpatialFactory
 * Sep 11, 2014 DR 17303    jgerth      Support for second standard latitude
 * Sep 23, 2021 8608        mapeters    Handle PDO.traceId changes
 * </pre>
 *
 * @author tk
 */
public class RegionalSatDecoder extends AbstractDecoder {

    private static final IUFStatusHandler handler = UFStatus
            .getHandler(AbstractDecoder.class);

    private String source;

    private String filename;

    /**
     * The decoder method uses the NetcdfFile API to retrieve the attributes and
     * satellite image data from the Alaska Region and GOES-R Proving Ground
     * netcdf3 files. These netcdf3 files are generated for use in Alaska and
     * the metadata and data are specified by the requirements for the Alaska
     * Region. Once the netcdf3 file is decoded, the metadata is stored in the
     * Satellite table in Postgres and the image data is stored in the HDF5
     * repository as Satellite records. The GIS map metadata is stored in the
     * satellite_spatial table by creating a SatMapCoverage object.
     *
     * The following parameters are set in the spring configuraiton file
     * alaskasat-ingest.xml and the dao and source members are set when the
     * RegionalSatDecoder instance is initialized:
     *
     * @param data
     *            The file byte array data to be decoded.
     * @return The decoded data record(s).
     */
    public PluginDataObject[] decode(byte[] data) throws Exception {

        PluginDataObject[] retData = null;

        SatelliteRecord record = null;

        NetcdfFile netCdfFile = null;

        if ((data != null) && (data.length > 0)) {

            Calendar calendar = Calendar
                    .getInstance(TimeZone.getTimeZone("GMT"));

            record = new SatelliteRecord();

            // String filename = "alaska_netcdf3"; // dummy filename; TODO: get
            // filename from camel context?
            netCdfFile = NetcdfFile.openInMemory(filename, data);

            // set the source; Alaska Region
            String gaSourceStr = "Unknown";
            Attribute gaSource = netCdfFile.findGlobalAttribute("source");
            if (gaSource != null) {
                gaSourceStr = gaSource.getStringValue().trim();
            }
            // lookup source value
            record.setSource(getSource(gaSourceStr).replace("/", " "));

            // set the creating entity
            Attribute satName = netCdfFile.findGlobalAttribute("satelliteName");
            // "HRPT"; "GOESR-PG"; "Blended2";
            String entity = null;
            if (satName != null) {
                entity = satName.getStringValue().trim();
            }

            if (entity != null) {
                String parsed = getCreatingEntity(entity);
                if ((parsed != null) && (parsed.length() > 0)) {
                    record.setCreatingEntity(parsed.replace("/", " "));
                } else {
                    record.setCreatingEntity(entity.replace("/", " "));
                }
            } else {
                record.setCreatingEntity("Unknown");
            }

            // read the sector ID, may need to change to use satelliteSector
            // attribute?
            String sector = netCdfFile.findGlobalAttribute("depictorName")
                    .getStringValue().trim();
            record.setSectorID(sector);

            // read and set the physical element
            PhysicalElementValue pev = null;
            Attribute chan = netCdfFile.findGlobalAttribute("channel");
            if (chan != null) {
                String channel = chan.getStringValue().trim();

                pev = getPhysicalElement(entity, channel);
                String element = pev.name;
                if (pev.name != null) {
                    record.setPhysicalElement(element.replace("/", " "));
                } else {
                    record.setPhysicalElement(channel.replace("/", " "));
                }
            } else {
                record.setPhysicalElement("Imager Visible");
            }

            // read and set the units (IRPixel, GenericPixel, ...)
            // defined in physicalElements.xml lookup file
            if (pev != null) {
                String units = pev.units;
                if (pev.units != null) {
                    record.setUnits(units);
                }
            }

            // read the number of records
            int numRecords = netCdfFile.findDimension("y").getLength();

            // read the size of each record
            int recordSize = netCdfFile.findDimension("x").getLength();

            // read the valid time in seconds and store the time in milliseconds
            long time = netCdfFile.findVariable("validTime").readScalarLong();
            calendar.setTimeInMillis(time * TimeUtil.MILLIS_PER_SECOND);

            /*
             * Date date = new Date(); // used for setting the test data time
             * long time = date.getTime(); calendar.setTimeInMillis(time); //
             * need to convert seconds to millisconds
             */

            record.setDataTime(new DataTime(calendar));

            // set lov to central lon
            float lov = netCdfFile.findGlobalAttribute("centralLon")
                    .getNumericValue().floatValue();

            // STEREOGRAPHIC projection default
            int mapProjection = SatSpatialFactory.PROJ_POLAR;
            // set to zero for Stereographic projections
            float latin = 0.0f;
            Attribute rot = netCdfFile.findGlobalAttribute("rotation");
            float rotation = 0.0f;

            // read the projection
            String projection = netCdfFile.findGlobalAttribute("projName")
                    .getStringValue().trim();
            if (!"STEREOGRAPHIC".equalsIgnoreCase(projection)) {
                // get latin for projection from data
                latin = netCdfFile.findGlobalAttribute("centralLat")
                        .getNumericValue().floatValue();
                if ("LAMBERT".equalsIgnoreCase(projection)
                        || "LAMBERT_CONFORMAL".equalsIgnoreCase(projection)) {
                    mapProjection = SatSpatialFactory.PROJ_LAMBERT;
                    if (rot != null) {
                        rotation = rot.getNumericValue().floatValue();
                    }
                } else if ("MERCATOR".equalsIgnoreCase(projection)) {
                    mapProjection = SatSpatialFactory.PROJ_MERCATOR;
                } else if ("CYLINDRICAL_EQUIDISTANT"
                        .equalsIgnoreCase(projection)) {
                    mapProjection = SatSpatialFactory.PROJ_CYLIN_EQUIDISTANT;
                }

            } else {
                if (rot != null) {
                    rotation = rot.getNumericValue().floatValue();
                    // STEREOGRAPHIC projection add rotation to lov
                    lov += rotation;
                }
            }

            // declare and initialize
            float dx = 0.0f, dy = 0.0f, lo1 = 0.0f, la1 = 0.0f, lo2 = 0.0f,
                    la2 = 0.0f;
            int nx = 0, ny = 0;

            // Do specialized decoding and retrieve spatial data for projections
            if ((mapProjection == SatSpatialFactory.PROJ_MERCATOR)
                    || (mapProjection == SatSpatialFactory.PROJ_LAMBERT)
                    || (mapProjection == SatSpatialFactory.PROJ_POLAR)
                    || (mapProjection == SatSpatialFactory.PROJ_CYLIN_EQUIDISTANT)) {

                // set number of points along x-axis
                nx = recordSize;
                // set number of points along y-axis
                ny = numRecords;

                // read the image as byte data and store as byte array
                record.setMessageData(netCdfFile.readSection("image")
                        .get1DJavaArray(Byte.class));

                // get the latitude of the first point, upper left corner
                la1 = netCdfFile.findGlobalAttribute("lat00").getNumericValue()
                        .floatValue();

                // get longitude of the first point, upper left corner
                lo1 = (netCdfFile.findGlobalAttribute("lon00").getNumericValue()
                        .floatValue());

                // get the pixel spacing
                dx = netCdfFile.findGlobalAttribute("dxKm").getNumericValue()
                        .floatValue();
                // convert to meters from km
                dx *= 1000f;
                dy = netCdfFile.findGlobalAttribute("dyKm").getNumericValue()
                        .floatValue();
                // convert to meters from km
                dy *= 1000f;

                la2 = netCdfFile.findGlobalAttribute("latNxNy")
                        .getNumericValue().floatValue();
                lo2 = netCdfFile.findGlobalAttribute("lonNxNy")
                        .getNumericValue().floatValue();
            } else {
                throw new DecoderException(
                        "Unable to decode Satellite: Encountered Unknown projection");
            }

            SatMapCoverage mapCoverage;
            if (mapProjection == SatSpatialFactory.PROJ_LAMBERT && rot != null
                    && rotation != latin) {
                mapCoverage = SatSpatialFactory.getInstance()
                        .getCoverageTwoCorners(mapProjection, nx, ny, lov,
                                latin, rotation, la1, lo1, la2, lo2);
            } else {
                mapCoverage = SatSpatialFactory.getInstance()
                        .getCoverageTwoCorners(mapProjection, nx, ny, lov,
                                latin, la1, lo1, la2, lo2);
            }

            record.setCoverage(mapCoverage);
            record.setPersistenceTime(TimeUtil.newDate());

            // Set the data into the IDataRecord
            IDataRecord dataRec = SatelliteRecord.getDataRecord(record);
            if (dataRec != null) {
                record.setMessageData(dataRec);
            } else {
                handler.error(
                        String.format("Could not create datarecord for %s"),
                        record.getDataURI());
                record = null;
            }

        }

        if (record == null) {
            retData = new PluginDataObject[0];
        } else {
            retData = new PluginDataObject[] { record };
        }
        return retData;
    }

    // uses lookup map instead of database to store creating entity parameter
    // configuration
    private String getCreatingEntity(String name) {
        String value = RegionalSatLookups.getInstance().getCreatingEntity(name);
        return value != null ? value : String.format("Unknown-%s", name);
    }

    // uses lookup map instead of database to store physical element parameter
    // configuration
    private PhysicalElementValue getPhysicalElement(String satName,
            String channel) {
        PhysicalElementValue value = RegionalSatLookups.getInstance()
                .getPhysicalElement(satName, channel);
        return value != null ? value
                : new PhysicalElementValue(String.format("Unknown-%s", channel),
                        null);
    }

    // uses lookup map instead of database to store source parameter
    // configuration
    private String getSource(String name) {
        String value = RegionalSatLookups.getInstance().getSource(name);
        return value != null ? value : String.format("Unknown-%s", name);
    }

    /**
     * @return the source
     */
    public String getSource() {
        return source;
    }

    /**
     * @param source
     *            the source of the satellite images (Alaska Region)
     */
    public void setSource(String source) {
        this.source = source;
    }

    /**
     * @return the filename
     */
    public String getFilename() {
        return filename;
    }

    /**
     * @param filename
     *            the filename of the netcdf3 file
     */
    public void setFilename(String file) {
        this.filename = file;
    }

}